---
layout: epic
title: "On the obsessive statelessness of Peril"
date: 2018-06-15
author: [orta]
categories: [event, react, relay]
series: JavaScriptures
---

We're at 9 months of serious usage of Peril in Artsy. However, I've been worried.

To get you up to speed on Peril, Peril is a tool that takes GitHub webhooks, and makes it easy to build one-off
actions. It does this by having a per-account settings JSON, that connects JavaScript files to events from webhooks.
So, for example, you can write a rule which runs when closing an issue in GitHub that looks for associated Jira
tickets and resolves them. Peril provides no implicit actions like that, it instead offers a JavaScript runtime
environment optimised to this domain so you can make actions to fit your needs. Like a collection of single-file
[probots][probots].

Three months ago I started building out a "true" staging environment for Peril, one that allows any user or org on
GitHub to click a button and have Peril running on their account. Pulling this off has two real interesting
problems. Problem number one, security. Problem number two, my wallet.

Both of these issues stem from one simple problem: I need to run other people's code on my machines and I think they
should be able to store data. Which to be quite frank, is horrifying for a side-project. So, this post explores one
of main aspects which I've architected Peril to make this problem tractable. Avoiding storing state in the form of
data.

<!-- more -->

## Evaluation Context

Let's start with grounding how Peril works. The GitHub term for when someone adds Peril to their account is that it
creates an "Installation" of the [GitHub App][ga]. When a webhook from GitHub is sent to Peril, Peril grabs the
installation ID out a mongo database (yeah, I know, [how early-2010s][nosqliscool]) and pulls out a set of rules.
These rules are a map of Webhook events and actions to files. For example:

```json
{
  "rules": {
    "issues.opened": "artsy/peril-settings@danger/new-rfc.ts",
    "issue_comment": "artsy/peril-settings@org/markAsMergeOnGreen.ts",
    "pull_request.closed": "artsy/peril-settings@org/closed-prs.ts"
  }
}
```

This JSON maps opening an `issue` on GitHub to the evaluation of [`artsy/peril-settings@danger/new-rfc.ts`][rfc].
Peril runs the code which is declared as the `default export` with the JSON contents of the webhook. Then the file
can execute with the DSL provided in both [danger-js][] and [peril][ext]'s extensions. Peril's runtime is a
reasonably normal nodejs environment, so it supports working with `node_modules` to get stuff done.

This is where things get tricky, I first explored running code inside a tightened [virtual machine for node][vm2]
but eventually found enough holes that it was definitely not going to work against malicious user-code in the same
process as Peril. I lucked out to a potential answer to this when building out documentation for danger-js, which
could [feed many birds with one bowl][birds]. I could separate out the execution context (think: the runtime DSL,
the webhook JSON, and a bunch of installation specific config) as JSON and then pass that servers/processes then
turn that back into a useful runtime again in a separate client which runs the Dangerfile.

This idea was so compelling that I first used it to create a version of Danger that runs
[native to swift](https://github.com/danger/danger-swift) to figure out the kinks of what actually needs to be
transmitted. For Peril, this meant I could explore having the evaluation of user-code inside a completely different
server. I initially explored [using AWS Lambda][lambda] to run user-code, it's cheap, fast and mature. However, it's
possible for lambda instances to communicate with each other, as each run is not [a fresh process][lambda-reuse].
Making it not a secure platform for un-trusted code.

Not deterred, I explored the world of docker hosting as a service - first exploring running my own cluster [on AWS
ECS][ecs] and then settling [on Hyper][hyper] which offered sandboxed runs that booted in a few seconds. This is
where my first real dive into obsessive statelessness comes in. The docker container, and the hyper environment
contains no config by default. There is no Peril information available inside that runtime environment.

The information about a Peril run comes exclusively from Peril, in my head, I call this dependency injection for the
runtime environment. You can get a sense for what the full JSON looks like in this [fixtured file generated by
tests][fix]. It contains everything from (temporary) GitHub access tokens (only for your installation), to
environment variables for your run and the webhook JSON. The runtime environment only knows that information for the
duration of the process then all access tokens expires after 30 seconds of it starting regardless.

## User Sessions are ephemeral

With the runtime security figured out, and reasonably stable, I could start thinking about how people can control
their installations inside peril. Taking ideas from Ashkan's [post on JWT's][jwts] I explored using JWTs to a few
database-y related problems.

Problem one: User accounts. For Peril, the root elements of the domain model is a GitHub Installation. An
non-reflective perspective on building a web service would have me creating a user modal which can keep track of
permission and unique user settings. With [GDPR so freshly baked][gdpr] I really didn't see any actual value in
keeping this kind of data. Instead I added enough metadata to a JWT to replace a user model completely.

#### Here's an example JWT

```sh
eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpYXQiOjE1MjkxOTgwOTcsImlzcyI6WyIxMjMiLCIzMjEiXSwiZGF0YSI6eyJ1c2VyIjp7Im5hbWUiOiJPcnRhIiwiYXZhdGFyX3VybCI6Imh0dHBzOi8vYXZhdGFyczIuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3UvNDkwMzg_dj00In19LCJleHAiOjE1MjkyMDE2OTd9.E4NgIYCLdOkGO76fgQ7ERnYGErX90Bg_JpfmoPSmamU8F-6578FQBpEhu9sWo337uIc379L6P61NTKcpiC09jhhTXdESeiVT2-gW3HK1XhI7fRibu42wMi3R-mdv30u9uN75d-2QqQhxitk9Dr6u1zaPeMEVX6c-J9TGX6kVAPas506zn9vbnWrAEgpZnCC7c7-vgdoHOvTZE7ugjvi16GmMfQjKSFDAh43fpgf_2c9Es6RtB1vaTu1TVuVB-Slvu7NbczJQcGRa1fAPdKp8JWvaXXDYrKIDeSC-YJxZZcSqSAuso6UZ8-DJLcHVquEgZVM3AfSVgX04JORzA_G_wg
```

#### When decrypted

```json
{
  "iat": 1529198097,
  "iss": ["123", "321"],
  "data": {
    "user": {
      "name": "Orta",
      "avatar_url": "https://avatars2.githubusercontent.com/u/49038?v=4"
    }
  },
  "exp": 1529201697
}
```

So far, I think that's enough information. You can let people know what account they're logged into, and a show an
avatar in a UI. The JWT is generated when you log in to Peril via GitHub OAuth, and Peril looks up what
installations you have access to via the GitHub API. The connected installations are stamped into the JWT in the
`iss`section. This JWT is stored in the user's browser, and the server never stores it.

In every API call from the front-end, the server validates that the JWT was signed by Peril, and is not out of date.
If it's OK - the server trusts the data inside the JWT and you have access to administrate the issue. No stored
sessions, no stored users.

There's downsides to using a JWT like this. For example, what happens if the user is removed from the org? Until
that JWT has expired, the user will continue have access to the installation. This is a trade-off which I'm OK to
take right now. I think [this post][jwt_tradeoff] covers a lot of the downsides of this stateless JWT technique
well.

## Temporary Tokens

The user/authentication JWT is not the only JWT in play in Peril. I needed the ability for the JavaScript Runtime to
send messages back to the Peril server. Peril re-uses [JWTs for creating a short-lived (2 min) token][jwt_two] that
only has access to particular installation and can only run a particular set of mutations in the GraphQL API. This
token is a part of the data injected in at the start of the process. The Peril JavaScript DSL uses this token under
the hood when you run particular functions.

## Temporary Webhooks

With an an admin user interface set up, you can now get a good overview of what your installation looks like in
Peril. This is a good start, but it's a static representation of a live system. In order to do any development
inside Peril, you would need to keep triggering the same event inside the GitHub and seeing how Peril evaluates your
code. Event with the rich type definitions, you're unlikely to get it right first time.

And here's where I made a compromise or two, in favour of a good abstraction. Ash recommended that perhaps storing
webhooks from GitHub and making it feasible to re-send them in Peril would make a great development environment. I
couldn't think of a way to do that statelessly, so I opted to timebox them. Now you can trigger a 5 minute window on
an installtion where any event sent to Peril will be stored in mongo for a week. After that they're gone.

This is a great trade-off on data storage vs value of a feature. It's been the best idea so far on how to handle
building a development mode into Peril, so I wouldn't want to compromise the feature in favour of something that
won't store any data.

## Real-time logging

On the flip side, I spent a long time thinking about how I can get logs from a Peril run to a user without having to
store those.

I came up with what feels like such an obvious answer in retrospect. When you open up the admin dashboard, it
connects to Peril via a websocket. This websocket is used to send real-time updates about when an event is
triggering a dangerfile evaluation and its changing status. When the evaluation is finished, then the logs are
collected and sent through the websocket to any users connected to the associated installation. The feature is
particularly elegant because storing the logs for every Dangerfile run on something like S3 will not scale with my
wallet. Plus, I don't want to have access to your logs ideally.

[ga]:
  https://blog.github.com/2016-09-14-a-whole-new-github-universe-announcing-new-tools-forums-and-features/#integrate-seamlessly-with-github
[nosqliscool]: https://www.infoworld.com/article/2990184/database/nosql-simply-isnt-hip-anymore.html
[probots]: https://probot.github.io
[rfc]: https://github.com/artsy/peril-settings/blob/6ec744e552df0828b3de2c5bc72e97accc6f562f/danger/new-rfc.ts
[danger-js]: http://danger.systems/js/
[ext]: http://danger.systems/js/reference.html#PerilDSL
[vm2]: https://github.com/patriksimek/vm2
[lambda]: https://github.com/danger/peril/issues/159
[birds]: https://celebrateurbanbirds.org/learn/gardening/providing-water-for-birds/
[lambda-reuse]: https://aws.amazon.com/blogs/compute/container-reuse-in-lambda/
[ecs]: https://aws.amazon.com/ecs/
[hyper]: https://hyper.sh
[fix]:
  https://github.com/danger/peril/blob/master/source/github/events/handlers/_tests/fixtures/PerilRunnerEventBootStrapExample.json
[jwts]: https://artsy.github.io/blog/2016/10/26/jwt-artsy-journey/
[gdpr]: https://www.wired.co.uk/article/what-is-gdpr-uk-eu-legislation-compliance-summary-fines-2018
[jwt_two]:
  https://github.com/danger/peril/blob/59895d10255965ab5d76dac9362696632d135163/source/runner/sandbox/jwt.ts#L10-L56
[jwt_tradeoff]: http://cryto.net/~joepie91/blog/2016/06/13/stop-using-jwt-for-sessions/
